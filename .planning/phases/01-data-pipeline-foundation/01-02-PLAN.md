---
phase: 01-data-pipeline-foundation
plan: 02
type: tdd
wave: 2
depends_on:
  - "01-01"
files_modified:
  - backend/app/services/__init__.py
  - backend/app/services/data_fetcher.py
  - backend/tests/__init__.py
  - backend/tests/test_data_fetcher.py
autonomous: true
requirements:
  - DATA-01
  - DATA-03
  - DATA-04

must_haves:
  truths:
    - "fetch_all_stocks() returns a dict keyed by ticker with close_price and volume"
    - "fetch_all_stocks() returns empty dict on yfinance failure (not an exception)"
    - "validate_ticker_data() rejects rows where close_price is NaN or zero"
    - "validate_ticker_data() rejects rows with missing volume"
    - "Batch download uses a single yf.download() call, never a per-ticker loop"
  artifacts:
    - path: "backend/app/services/data_fetcher.py"
      provides: "yfinance batch fetch + validation"
      exports: ["fetch_all_stocks", "validate_ticker_data", "SEED_TICKERS"]
    - path: "backend/tests/test_data_fetcher.py"
      provides: "Pytest test suite for fetcher and validation"
      min_lines: 60
  key_links:
    - from: "backend/tests/test_data_fetcher.py"
      to: "backend/app/services/data_fetcher.py"
      via: "imports fetch_all_stocks, validate_ticker_data"
      pattern: "from.*data_fetcher.*import"
    - from: "backend/app/services/data_fetcher.py"
      to: "yfinance"
      via: "yf.download() batch call"
      pattern: "yf\\.download\\("
---

<objective>
TDD implementation of the yfinance batch data fetcher and data validation logic — the core data acquisition functions that DATA-01, DATA-03, and DATA-04 depend on.

Purpose: TDD ensures the fallback behavior and validation rules are correct by specification before integration. These are pure functions with defined I/O — ideal TDD candidates.
Output: Tested data_fetcher.py with fetch_all_stocks() and validate_ticker_data() functions.
</objective>

<execution_context>
@C:/Users/Yarin David/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Yarin David/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/01-data-pipeline-foundation/01-01-SUMMARY.md
</context>

<feature>
  <name>yfinance batch data fetcher with validation</name>
  <files>
    backend/app/services/data_fetcher.py
    backend/tests/test_data_fetcher.py
  </files>
  <behavior>
**fetch_all_stocks(tickers: list[str]) -> dict[str, dict]**
- Calls yf.download() once with all tickers in batch (period="2d", interval="1d", auto_adjust=True, progress=False, threads=True)
- Returns dict: { "AAPL": {"close_price": 182.5, "volume": 55000000.0}, ... }
- MultiIndex access: raw["Close"][ticker] for close, raw["Volume"][ticker] for volume
- Takes the most recent row (iloc[-1]) for each ticker
- On ANY exception from yfinance: logs the error, returns {} (empty dict — never raises)
- Skips tickers where validate_ticker_data() returns False

**validate_ticker_data(ticker: str, close: float, volume: float) -> bool**
- Returns False if close is NaN (math.isnan)
- Returns False if close <= 0
- Returns False if volume is NaN
- Returns False if volume <= 0
- Returns True otherwise

**SEED_TICKERS** — module-level list:
["AAPL", "MSFT", "NVDA", "AMD", "GOOGL", "TSLA", "RIVN", "JPM", "GS"]

Test cases:
- validate_ticker_data("AAPL", 182.5, 55000000) -> True
- validate_ticker_data("BAD", float("nan"), 1000) -> False
- validate_ticker_data("BAD", 100.0, float("nan")) -> False
- validate_ticker_data("BAD", 0.0, 1000) -> False
- validate_ticker_data("BAD", -5.0, 1000) -> False
- validate_ticker_data("BAD", 100.0, 0.0) -> False
- fetch_all_stocks([]) -> {} (empty tickers list)
- fetch_all_stocks raises no exception when yfinance throws (mock yf.download to raise Exception)
- fetch_all_stocks skips tickers that fail validation (mock raw data with NaN for one ticker)
  </behavior>
  <implementation>
After tests pass:
```python
import math
import logging
import yfinance as yf

logger = logging.getLogger(__name__)

SEED_TICKERS = ["AAPL", "MSFT", "NVDA", "AMD", "GOOGL", "TSLA", "RIVN", "JPM", "GS"]

def validate_ticker_data(ticker: str, close: float, volume: float) -> bool:
    if math.isnan(close) or close <= 0:
        return False
    if math.isnan(volume) or volume <= 0:
        return False
    return True

def fetch_all_stocks(tickers: list[str] = None) -> dict[str, dict]:
    if tickers is None:
        tickers = SEED_TICKERS
    if not tickers:
        return {}
    try:
        raw = yf.download(tickers, period="2d", interval="1d",
                          auto_adjust=True, progress=False, threads=True)
        result = {}
        for ticker in tickers:
            try:
                close = float(raw["Close"][ticker].iloc[-1])
                volume = float(raw["Volume"][ticker].iloc[-1])
                if validate_ticker_data(ticker, close, volume):
                    result[ticker] = {"close_price": close, "volume": volume}
                else:
                    logger.warning("Ticker %s failed validation (close=%s, volume=%s)", ticker, close, volume)
            except Exception as e:
                logger.warning("Could not extract data for %s: %s", ticker, e)
        return result
    except Exception as e:
        logger.error("yfinance batch download failed: %s", e)
        return {}
```

**TDD Cycle:**
1. RED: Write test_data_fetcher.py with all test cases → run pytest → all FAIL
2. GREEN: Write minimal data_fetcher.py to pass → run pytest → all PASS
3. REFACTOR: Clean up if needed → run pytest → still PASS

**Commit after each phase:**
- RED: `git commit -m "test(01-02): add failing tests for data_fetcher validation and fetch"`
- GREEN: `git commit -m "feat(01-02): implement data_fetcher with batch fetch and validation"`
- REFACTOR (if any): `git commit -m "refactor(01-02): clean up data_fetcher"`
  </implementation>
</feature>

<verification>
```bash
cd backend
pytest tests/test_data_fetcher.py -v
```
All tests pass. At least 9 test functions present (covering validate_ticker_data edge cases + fetch_all_stocks fallback + batch behavior).
</verification>

<success_criteria>
- pytest tests/test_data_fetcher.py -v → all green
- No test calls yf.download directly (uses unittest.mock.patch to avoid real network calls)
- fetch_all_stocks never raises an exception (returns {} on failure)
- validate_ticker_data correctly rejects NaN/zero close or volume
- data_fetcher.py uses a single yf.download() call (grep confirms no per-ticker download loop)
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-pipeline-foundation/01-02-SUMMARY.md` using the summary template.
</output>
