---
phase: 02-ranking-algorithm
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - backend/app/services/ranking_engine.py
  - backend/tests/test_ranking_engine.py
autonomous: true
requirements: [ALGO-01, ALGO-02, ALGO-03, ALGO-05, ALGO-06]

must_haves:
  truths:
    - "normalize_factor() caps values at ±3 std dev before computing Z-scores"
    - "normalize_factor() returns all zeros (not divide-by-zero) when std == 0"
    - "Single-stock domain returns composite_score=50.0 and rank=1 without running Z-score"
    - "Missing factor (None raw value) is excluded and remaining weights are proportionally reweighted"
    - "composite_score is scaled to 0–100 within the peer group (best stock = 100, worst = 0)"
    - "StockScore.factor_scores contains raw, normalized, weighted, and effective_weight for each factor"
    - "rank_domain() returns StockScore objects ranked 1=best within the domain"
  artifacts:
    - path: "backend/app/services/ranking_engine.py"
      provides: "Pure ranking engine — normalize_factor, compute_composite, scale_to_0_100, rank_domain, FactorScore dataclass, StockScore dataclass"
      exports: [FactorScore, StockScore, normalize_factor, compute_composite, scale_to_0_100, rank_domain]
    - path: "backend/tests/test_ranking_engine.py"
      provides: "Comprehensive pytest suite covering all 6 edge cases"
      min_lines: 80
  key_links:
    - from: "backend/tests/test_ranking_engine.py"
      to: "backend/app/services/ranking_engine.py"
      via: "direct import of rank_domain, normalize_factor, StockScore, FactorScore"
      pattern: "from app\\.services\\.ranking_engine import"
---

<objective>
Build the isolated, pure ranking engine module using TDD — every algorithm behavior is proven by a failing test before implementation.

Purpose: The ranking engine IS the core product differentiator. TDD ensures correctness of normalization, reweighting, and scaling math before any I/O layer touches it.
Output: ranking_engine.py (pure, no DB/yfinance imports) + comprehensive pytest suite (GREEN).
</objective>

<execution_context>
@C:/Users/Yarin David/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Yarin David/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/app/services/data_fetcher.py
</context>

<feature>
  <name>Ranking Engine — normalize, weight, scale, rank</name>
  <files>
    backend/app/services/ranking_engine.py
    backend/tests/test_ranking_engine.py
  </files>

  <behavior>
    ## Data Structures

    ```python
    from dataclasses import dataclass
    from typing import Optional

    @dataclass
    class FactorScore:
        raw: Optional[float]
        normalized: Optional[float]   # None when factor excluded (missing raw)
        weighted: Optional[float]     # None when factor excluded
        effective_weight: float       # Actual weight used after proportional reweighting

    @dataclass
    class StockScore:
        ticker: str
        composite_score: float        # 0–100 within peer domain
        rank: int                     # 1 = best
        factor_scores: dict[str, FactorScore]
    ```

    ## Factor Weights (named constants — must sum to 1.0)

    ```python
    WEIGHT_MOMENTUM = 0.30          # 5-day price return — strongest short-term signal
    WEIGHT_VOLUME_CHANGE = 0.20     # 5-day volume change — confirms momentum with liquidity
    WEIGHT_VOLATILITY = 0.20        # 21-day rolling std (INVERTED) — penalizes instability
    WEIGHT_RELATIVE_STRENGTH = 0.15 # stock return minus domain median — pure peer comparison
    WEIGHT_FINANCIAL_RATIO = 0.15   # trailingPE (INVERTED) — cheaper = higher score
    ```

    ## Functions

    ### normalize_factor(values: list[Optional[float]]) -> list[Optional[float]]

    - Input: list of raw factor values (None = missing for that ticker)
    - Non-None values: cap at mean ± 3*std (population std, ddof=0) BEFORE Z-scoring
    - Z-score = (capped_value - mean) / std
    - If std == 0.0: all Z-scores = 0.0 (do NOT divide by zero)
    - None inputs pass through as None outputs (preserve position)
    - If fewer than 2 non-None values: return all None (cannot normalize)

    Cases:
    - [1.0, 2.0, 3.0] -> Z-scored list (mean=2, std=~0.816)
    - [5.0, 5.0, 5.0] -> [0.0, 0.0, 0.0]  (std==0 guard)
    - [None, 2.0, 3.0] -> [None, z1, z2]  (None preserved at index 0)
    - [100.0, 2.0, 3.0] -> outlier capped at mean+3σ before Z-scoring
    - [1.0] -> [None]  (single value, cannot normalize; edge case: single-stock handled by rank_domain before this)

    ### compute_composite(normalized_dict: dict[str, Optional[float]], weights: dict[str, float]) -> tuple[float, dict[str, float]]

    - Input: {factor_name: normalized_z_score_or_None}, {factor_name: base_weight}
    - Exclude None factors; reweight remaining proportionally so they sum to 1.0
    - If ALL factors are None: return (0.0, {})
    - Returns: (weighted_sum, {factor_name: effective_weight_used})

    Cases:
    - All present: weighted sum using base weights
    - One missing: remaining 4 factors' weights scaled up proportionally to sum to 1.0
    - All missing: (0.0, {})

    ### scale_to_0_100(composite_scores: dict[str, float]) -> dict[str, float]

    - Input: {ticker: composite_weighted_sum}
    - Min-max scale within the group: score = (v - min) / (max - min) * 100
    - If max == min (all identical or single stock): all scores = 50.0
    - Returns: {ticker: 0_to_100_score}

    ### rank_domain(stocks_data: dict[str, dict[str, Optional[float]]]) -> dict[str, StockScore]

    - Input: {ticker: {factor_name: raw_value_or_None}}
    - Single stock: return {ticker: StockScore(composite_score=50.0, rank=1, factor_scores={...})}
    - Empty dict: return {}
    - Full pipeline: normalize each factor across all tickers → compute composite per ticker → scale to 0–100 → assign ranks (1=highest score)
    - Returns: {ticker: StockScore}

  </behavior>

  <tdd_cases>
    ## 6 Required Test Cases

    ### Case 1: Single-stock domain
    Input: {"AAPL": {"momentum": 0.05, "volume_change": 0.10, "volatility": -0.02, "relative_strength": 0.01, "financial_ratio": -15.0}}
    Expected: composite_score == 50.0, rank == 1

    ### Case 2: std == 0 guard (all identical factor values)
    Input: 3 stocks all with momentum=0.05 (same value)
    Expected: normalize_factor([0.05, 0.05, 0.05]) == [0.0, 0.0, 0.0]
    (no ZeroDivisionError, no NaN)

    ### Case 3: Outlier capping
    Input: normalize_factor([1.0, 2.0, 3.0, 100.0])
    Expected: the value 100.0 is capped to mean + 3*std BEFORE Z-scoring; result[-1] < 5.0
    (verify capping actually fires — uncapped result would be >> 5)

    ### Case 4: Missing factor reweighting
    Input: {"AAPL": {"momentum": 0.05, "volume_change": None, "volatility": -0.02, "relative_strength": 0.01, "financial_ratio": -15.0},
            "MSFT": {"momentum": 0.03, "volume_change": None, "volatility": -0.01, "relative_strength": 0.02, "financial_ratio": -20.0}}
    Expected:
    - factor_scores["volume_change"].normalized is None for both
    - effective_weight for remaining 4 factors sums to 1.0
    - WEIGHT_VOLUME_CHANGE (0.20) is redistributed, not silently dropped

    ### Case 5: 0–100 scaling correctness
    Input: 3 stocks with distinct scores
    Expected: best stock composite_score == 100.0, worst == 0.0, middle is between

    ### Case 6: Score breakdown structure
    For any result from rank_domain():
    Expected: each StockScore has factor_scores dict with keys matching the 5 factor names;
    each FactorScore has .raw (float or None), .normalized (float or None),
    .weighted (float or None), .effective_weight (float)

  </tdd_cases>

  <implementation>
    ## Red-Green-Refactor Plan

    RED (write all 6 failing tests first):
    - Create backend/tests/test_ranking_engine.py with all 6 test cases
    - Import from backend/app/services/ranking_engine — will fail ImportError
    - Run: cd backend && python -m pytest tests/test_ranking_engine.py -v
    - Commit: test(02-01): add failing tests for ranking engine

    GREEN (implement ranking_engine.py):
    - Create backend/app/services/ranking_engine.py
    - Implement dataclasses first (FactorScore, StockScore)
    - Implement named weight constants
    - Implement normalize_factor() — numpy for mean/std with ddof=0
    - Implement compute_composite() — proportional reweighting
    - Implement scale_to_0_100() — min-max within group
    - Implement rank_domain() — orchestrates full pipeline
    - Run: cd backend && python -m pytest tests/test_ranking_engine.py -v
    - All 6 tests must pass
    - Commit: feat(02-01): implement ranking engine

    REFACTOR (optional — only if code is unclear):
    - Add inline comments explaining weight rationale
    - Ensure no magic numbers remain (all weights use named constants)
    - Run tests again to confirm still GREEN
    - Commit: refactor(02-01): add weight rationale comments

    ## Implementation Notes

    - Use numpy for mean/std (already in requirements.txt via pandas)
    - import numpy as np; NOT scipy (not in requirements)
    - ddof=0 everywhere (population std, NOT sample std)
    - Do NOT import from app.database, app.models, yfinance — pure module only
    - financial_ratio None is the NORMAL case (trailingPE silently None from yfinance) — reweighting fires regularly, not exceptionally
    - volatility raw value is already inverted (multiplied by -1) BEFORE being passed into rank_domain — the engine does NOT invert it again
  </implementation>
</feature>

<verification>
cd backend && python -m pytest tests/test_ranking_engine.py -v
All 6 test cases pass (GREEN).
No import of app.database, yfinance, or any I/O module inside ranking_engine.py.
grep -n "import" backend/app/services/ranking_engine.py shows only: dataclasses, typing, numpy.
</verification>

<success_criteria>
- backend/app/services/ranking_engine.py exists with FactorScore, StockScore, normalize_factor, compute_composite, scale_to_0_100, rank_domain exported
- backend/tests/test_ranking_engine.py exists with all 6 edge case tests
- pytest passes: 6/6 tests GREEN
- Named weight constants defined at module level, sum to 1.0
- No I/O dependencies inside ranking_engine.py
</success_criteria>

<output>
After completion, create `.planning/phases/02-ranking-algorithm/02-01-SUMMARY.md`
</output>
