---
phase: 04-authentication-personalization
plan: 02
type: execute
wave: 2
depends_on: [04-01]
files_modified:
  - backend/app/routers/preferences.py
  - backend/app/main.py
autonomous: true
requirements: [AUTH-04]

must_haves:
  truths:
    - "Authenticated user can GET their saved domain list"
    - "Authenticated user can PUT a new domain list"
    - "Unauthenticated requests to /api/preferences return 401"
  artifacts:
    - path: "backend/app/routers/preferences.py"
      provides: "GET /api/preferences + PUT /api/preferences"
      exports: ["router"]
    - path: "backend/app/main.py"
      provides: "preferences router registered"
      contains: "preferences"
  key_links:
    - from: "backend/app/routers/preferences.py"
      to: "get_current_user"
      via: "Depends(get_current_user)"
      pattern: "Depends\\(get_current_user\\)"
    - from: "backend/app/routers/preferences.py"
      to: "user_preferences table"
      via: "sync session SELECT/INSERT/UPDATE"
      pattern: "user_preferences"
---

<objective>
Add preferences API router: GET and PUT /api/preferences protected by get_current_user.

Purpose: Enables frontend to load and save domain filter selections per user.
Output: Two protected endpoints backed by user_preferences table.
</objective>

<execution_context>
@C:/Users/Yarin David/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Yarin David/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@backend/app/main.py
@backend/app/database.py
@backend/app/routers/auth.py
@.planning/phases/04-authentication-personalization/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create preferences router</name>
  <files>backend/app/routers/preferences.py</files>
  <action>
    Create `backend/app/routers/preferences.py`:

    ```python
    from fastapi import APIRouter, Depends, HTTPException
    from pydantic import BaseModel
    from sqlalchemy import text
    from app.database import get_db  # async session dependency
    from app.routers.auth import get_current_user

    router = APIRouter(prefix="/api/preferences", tags=["preferences"])

    class PreferencesPayload(BaseModel):
        domains: list[str]

    @router.get("")
    async def get_preferences(
        user_id: str = Depends(get_current_user),
        db=Depends(get_db),
    ):
        row = await db.execute(
            text("SELECT domains FROM user_preferences WHERE user_id = :uid"),
            {"uid": user_id},
        )
        result = row.fetchone()
        return {"domains": result[0] if result else []}

    @router.put("")
    async def put_preferences(
        payload: PreferencesPayload,
        user_id: str = Depends(get_current_user),
        db=Depends(get_db),
    ):
        await db.execute(
            text("""
                INSERT INTO user_preferences (user_id, domains)
                VALUES (:uid, :domains)
                ON CONFLICT (user_id)
                DO UPDATE SET domains = :domains, updated_at = now()
            """),
            {"uid": user_id, "domains": payload.domains},
        )
        await db.commit()
        return {"domains": payload.domains}
    ```

    Note: The ON CONFLICT clause requires a unique constraint on user_id. Add it to the migration or handle by checking if row exists first. Use the check-then-upsert approach if unique constraint is not present:
    - SELECT first, then INSERT or UPDATE accordingly.
    - Keep this within the same async session — no sync engine in route handlers.
  </action>
  <verify>
    ```bash
    cd backend && python -c "from app.routers.preferences import router; print([r.path for r in router.routes])"
    ```
    Should print `['/api/preferences', '/api/preferences']`.
  </verify>
  <done>GET and PUT routes importable; depend on get_current_user and get_db</done>
</task>

<task type="auto">
  <name>Task 2: Register preferences router in main.py</name>
  <files>backend/app/main.py</files>
  <action>
    In `backend/app/main.py`, import and include the preferences router:
    ```python
    from app.routers.preferences import router as preferences_router
    app.include_router(preferences_router)
    ```
    Place alongside existing router registrations. No other changes to main.py.
  </action>
  <verify>
    ```bash
    cd backend && uvicorn app.main:app --host 0.0.0.0 --port 8000 &
    sleep 3
    curl -s http://localhost:8000/openapi.json | python -c "import sys,json; routes=json.load(sys.stdin)['paths']; print([k for k in routes if 'preferences' in k])"
    kill %1
    ```
    Should show `/api/preferences` in paths.
  </verify>
  <done>/api/preferences GET and PUT appear in OpenAPI spec; unauthenticated GET returns 422 (missing Authorization header)</done>
</task>

</tasks>

<verification>
```bash
cd backend && uvicorn app.main:app --port 8000 &
sleep 3
curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/api/preferences
kill %1
```
Should return `422` (Authorization header required) — not 404 or 500.
</verification>

<success_criteria>
- GET /api/preferences returns 422 without Authorization header
- GET /api/preferences returns 200 with {"domains": [...]} for valid JWT
- PUT /api/preferences with valid JWT and {"domains": ["tech"]} saves and returns updated list
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-personalization/04-02-SUMMARY.md`
</output>
